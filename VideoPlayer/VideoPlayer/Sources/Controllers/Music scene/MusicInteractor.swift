//
//  MusicInteractor.swift
//  VideoPlayer
//
//  Created by Sergey Pohrebnuak on 13.01.2021.
//  Copyright (c) 2021 Sergey Pohrebnuak. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol MusicBusinessLogic {
    func fetchLocalItems(request: Music.FetchLocalItems.Request)
    func startPlayOrDownload(request: Music.StartPlayOrDownload.Request)
    func updatePlayingSongInfo(request: Music.UpdatePlayingSongInfo.Request)
    func removeMediaItem(request: Music.DeleteMediaItem.Request)
    func findMediaItems(request: Music.FindMediaItems.Request)
}

protocol MusicDataStore {
    
}

final class MusicInteractor: MusicBusinessLogic, MusicDataStore {
    
    var presenter: MusicPresentationLogic?
    //workerks
    private var playWorker: PlayMusicWorker?
    
    //business logic variables
    private(set) var itemsSet = Set<MusicOrVideoItem>()
    private var itemsArray: [MusicOrVideoItem] {
        return Array(itemsSet).sorted { $0.addedDate > $1.addedDate }
    }
    private var indexOfItemForPlay = 0
    
    // MARK: Do something
    func fetchLocalItems(request: Music.FetchLocalItems.Request) {
        itemsSet = CoreManager.shared.getMediaItems()
        
        let response = Music.FetchLocalItems.Response(musicItems: itemsArray)
        presenter?.showMusicItems(response: response)
    }
    
    func startPlayOrDownload(request: Music.StartPlayOrDownload.Request) {
        indexOfItemForPlay = request.index
        
        guard   !itemsArray.isEmpty,
                indexOfItemForPlay >= 0,
                indexOfItemForPlay < itemsArray.count
        else {return}
        
        let itemForPlay = itemsArray[indexOfItemForPlay]
        
        let fileUrl = FileManager.default.applicationSupportDirectory.appendingPathComponent(itemForPlay.fileNameInStorage,
                                                                                   isDirectory: false)
        guard FileManager.default.fileExists(atPath: fileUrl.path) else {
            //TODO: here should call worker which download items from cloud
            print("❌ file not found on device")
            return
        }
        
        if itemForPlay.isNew {
            itemsArray[indexOfItemForPlay].isNew = false
            saveChanges()
            let response = Music.StartPlayOrDownload.Response(musicItem: itemsArray[indexOfItemForPlay],
                                                              atIndex: indexOfItemForPlay)
            presenter?.unnewMusicItem(response: response)
        }

        playWorker = PlayMusicWorker()
        guard playWorker?.playSongByURL(url: fileUrl) ?? false else {return}
        playWorker?.delegate = self
    }
    
    func removeMediaItem(request: Music.DeleteMediaItem.Request) {
        let removedObjectOptional = itemsSet.first{ $0.localId == request.localId }
        guard let removedObject = removedObjectOptional else { return }
        
        itemsSet.remove(removedObject)
        CoreManager.shared.coreManagerContext.delete(removedObject)
        saveChanges()
        
        FileManager.default.removeFileFromApplicationSupportDirectory(withName: removedObject.fileNameInStorage)
        
        let response = Music.DeleteMediaItem.Response(musicItems: itemsArray)
        presenter?.updateMusicItemsAfterDeleting(response: response)
    }
    
    func findMediaItems(request: Music.FindMediaItems.Request) {
        let searchText = request.searchText
        var resultArray = itemsArray
        
        if !searchText.isEmpty  {
            resultArray = itemsSet.filter { $0.displayFileName.contains(searchText) }
        }
        
        let response = Music.FindMediaItems.Response(musicItems: resultArray)
        presenter?.updateMusicItemsAfterSearch(response: response)
    }
    
    func updatePlayingSongInfo(request: Music.UpdatePlayingSongInfo.Request) {
        playWorker?.callDelegateWithUpdatedInfoIfPossible()
    }
    
    private func saveChanges() {
        CoreManager.shared.saveContext()
    }
}

extension MusicInteractor: PlayMusicWorkerDelegate {
    func didFinishPlaySong() {
        
    }
    
    func updatedPlayingStateAndInfo(playingInfo: Music.UpdatePlayingSongInfo.SongInfoForDisplay) {
        var response = Music.UpdatePlayingSongInfo.Response(info: playingInfo)
        response.info.title = itemsArray[indexOfItemForPlay].displayFileName
        presenter?.updatePlayingSongInfo(response: response)
    }
}
